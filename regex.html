<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Audiowide&family=Lobster&family=Roboto:ital,wght@0,500;0,700;0,900;1,300&family=The+Nautigal:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <title>Regex JS</title>
    <link rel="stylesheet" href="main.css" />
    <script type="module" src="main.js" defer></script>
  </head>
  <body>
    <nav class="main-nav">
      <div class="navBar-menu">
        <div class="navBar-btn"></div>
      </div>
      <h2>JS RegExp</h2>
      <ul class="navBar">
        <li class="navBar__list-item">
          <a href="index.html" title="FCC Vanilla javaScript">Vanilla JS</a>
        </li>
        <li class="navBar__list-item">
          <a href="#welcome" title="">Welcome</a>
        </li>
        <li class="navBar__list-item">
          <a href="#creatingRegExp" title="FCC Notes ES6">Create a RegExp</a>
        </li>
        <li class="navBar__list-item">
          <a href="#patterns" title="FCC Notes ES6">Patterns</a>
        </li>
        <li class="navBar__list-item">
          <a href="#characterClasses" title="">Character classes</a>
        </li>
        <li class="navBar__list-item">
          <a href="#assertions" title="">Assertions</a>
        </li>
        <li class="navBar__list-item">
          <a href="#groupsRanges" title="">Groups & Ranges</a>
        </li>
        <li class="navBar__list-item">
          <a href="#quantifiers" title="">Quantifiers</a>
        </li>
        <li class="navBar__list-item">
          <a href="#unicodeEscape" title="">Unicode Escapes</a>
        </li>
        <li class="navBar__list-item">
          <a href="#flags" title="">Flags</a>
        </li>
        <li class="navBar__list-item">
          <a href="#methods" title="">Methods</a>
        </li>
      </ul>
    </nav>
    <header class="main-header">
      <div id="darkMode" class="darkMode">
        <button id="darkModeBtn" class="dmToggle"></button>
      </div>
      <h1>Regular Expressions</h1>
    </header>
    <div class="intro">
      <div class="readMore-top">
        <p>
          Hello, my Name is Christopher. I'm learning Frontend Web Devlopment on
          my own. I've found several resourses available to anyone wanting to
          learn web development.
        </p>
      </div>
      <div class="readMore-section">
        <p>
          I use a few different web sites for free courses and reference
          material, like "Free code Camp", "W3 Schools" and "MDN Web Docs". I
          use these sites for theory, testing and documentation. I also found
          lots of videos on YouTube that were great for beginers right up to
          more advanced programming. I did find the theory and having lectures
          from videos beneficial but they just didn't complete the learning
          process, I had to take notes too. I try to reference the sites I used
          for source material when possible in my notes.
        </p>
        <p>
          I've started to build several reference document web pages to practice
          building web pages while taking notes on different subjects.
        </p>
      </div>
      <br />
      <button class="btn-readMore" id="readMoreIntro">
        read more
        <img
          class="readMore-img"
          src="./img/icon/icons8-chevron-24.png"
          alt=""
        />
      </button>
    </div>
    <section class="welcome chapter">
      <h2>Welcome</h2>
      <div class="readMore-top">
        <p>
          Regular expressions, often shortened to "regex" or "regexp". Regular
          expressions are very powerful, but can be hard to read because they
          use special characters to make more complex, flexible matches.
        </p>
      </div>
      <div class="readMore-section">
        <div class="mdnDoc">
          <p>
            Regular expressions are patterns used to match character
            combinations in strings. In JavaScript, regular expressions are also
            objects. These patterns are used with the exec() and test() methods
            of RegExp, and with the match(), matchAll(), replace(),
            replaceAll(), search(), and split() methods of String.
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
      </div>
      <br />
      <button class="btn-readMore" id="readMoreWelcome">
        Read More
        <img
          class="readMore-img"
          src="./img/icon/icons8-chevron-24.png"
          alt=""
        />
      </button>
      <div class="tutor">
        <section class="desktop">
          <p>Free Code Camp</p>
          <div class="desktop__monitor">
            <picture>
              <iframe
                width="560"
                height="315"
                src="https://www.youtube.com/embed/ZfQFUJhPqMM"
                title="YouTube video player"
                frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen
              ></iframe>
            </picture>
            <p>Softcorp TV</p>
          </div>
          <p>Learn Regular Expressions</p>
        </section>

      </div>
    </section>
    <main>
      <section class="chapter" id="creatingRegExp">
        <h2>Creating a regular expression</h2>
        <p class="subHeader">
          You construct a regular expression in one of two ways:
        </p>
        <div class="mdnDoc">
          <p>
            Using a <strong>expression literal</strong>, which consists of a
            pattern enclosed between slashes, as follows:
          </p>
          <pre class="codeExample">
            <code>
  const re = /ab+c/;
            </code>
          </pre>
          <p>
            Regular expression literals provide compilation of the regular
            expression when the script is loaded. If the regular expression
            remains constant, using this can improve performance.
          </p>
        </div>
        <br />
        <div class="mdnDoc">
          <p>
            Using the <strong>constructor function</strong> of the
            <strong><span class="operator">new</span> RegExp()</strong> object,
            as follows:
          </p>
          <pre class="codeExample">
            <code>
  const re = new RegExp('ab+c');
            </code>
          </pre>
          <p>
            Using the constructor function provides runtime compilation of the
            regular expression. Use the constructor function when you know the
            regular expression pattern will be changing, or you don't know the
            pattern and are getting it from another source, such as user input.
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
      </section>
      <br />
      <hr />
      <section class="chapter" id="patterns">
        <h2>Patterns</h2>
        <div class="mdnDoc">
          <p class="subHeader">Writing a regular expression pattern:</p>
          <p>
            A regular expression pattern is composed of simple characters, such
            as /abc/, or a combination of simple and special characters, such as
            /ab*c/ or /Chapter (\d+)\.\d*/. The last example includes
            parentheses, which are used as a memory device. The match made with
            this part of the pattern is remembered for later use, as described
            in Using groups.
          </p>
          <p>
            Simple patterns are constructed of characters for which you want to
            find a direct match. For example, the pattern /abc/ matches
            character combinations in strings only when the exact sequence "abc"
            occurs (all characters together and in that order).
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">Using special characters:</p>
          <p>
            When the search for a match requires something more than a direct
            match, such as finding one or more b's, or finding white space, you
            can include special characters in the pattern. For example, to match
            a single "a" followed by zero or more "b"s followed by "c", you'd
            use the pattern /ab*c/: the * after "b" means "0 or more occurrences
            of the preceding item." In the string "cbbabbbbcdebc", this pattern
            will match the substring "abbbbc".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">Using Parentheses:</p>
          <p>
            Parentheses around any part of the regular expression pattern causes
            that part of the matched substring to be remembered. Once
            remembered, the substring can be recalled for other use. See
            <a style="color: white" href="#groupsRanges"> Groups and ranges</a>
            for more details.
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
      </section>
      <br />
      <hr />
      <section class="chapter" id="characterClasses">
        <h2>Character Classes</h2>
        <p></p>
        <div class="mdnDoc">
          <p class="subHeader">\</p>
          <p>
            Indicates that the following character should be treated specially,
            or "escaped". It behaves one of two ways.
          </p>
          <ul>
            <li>
              For characters that are usually treated literally, indicates that
              the next character is special and not to be interpreted literally.
              For example, /b/ matches the character "b". By placing a backslash
              in front of "b", that is by using /\b/, the character becomes
              special to mean match a word boundary.
            </li>
            <li>
              For characters that are usually treated specially, indicates that
              the next character is not special and should be interpreted
              literally. For example, "*" is a special character that means 0 or
              more occurrences of the preceding character should be matched; for
              example, /a*/ means match 0 or more "a"s. To match * literally,
              precede it with a backslash; for example, /a\*/ matches "a*".
            </li>
          </ul>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">.</p>
          <p>Has one of the following meanings:</p>
          <ul>
            <li>
              Matches any single character except line terminators: \n, \r,
              \u2028 or \u2029. For example, /.y/ matches "my" and "ay", but not
              "yes", in "yes make my day".
            </li>
            <li>
              Inside a character class, the dot loses its special meaning and
              matches a literal dot.
            </li>
          </ul>
          <p>
            Note that the m multiline flag doesn't change the dot behavior. So
            to match a pattern across multiple lines, the character class [^]
            can be used — it will match any character including newlines.
          </p>
          <p>
            ES2018 added the s "dotAll" flag, which allows the dot to also match
            line terminators.
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\d</p>
          <p>
            Matches any digit (Arabic numeral). Equivalent to [0-9]. For
            example, /\d/ or /[0-9]/ matches "2" in "B2 is the suite number".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\D</p>
          <p>
            Matches any character that is not a digit (Arabic numeral).
            Equivalent to [^0-9]. For example, /\D/ or /[^0-9]/ matches "B" in
            "B2 is the suite number".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\w</p>
          <p>
            Matches any alphanumeric character from the basic Latin alphabet,
            including the underscore. Equivalent to [A-Za-z0-9_]. For example,
            /\w/ matches "a" in "apple", "5" in "$5.28", "3" in "3D" and "m" in
            "Émanuel".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\W</p>
          <p>
            Matches any character that is not a word character from the basic
            Latin alphabet. Equivalent to [^A-Za-z0-9_]. For example, /\W/ or
            /[^A-Za-z0-9_]/ matches "%" in "50%" and "É" in "Émanuel".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\s</p>
          <p>
            Matches a single white space character, including space, tab, form
            feed, line feed, and other Unicode spaces. Equivalent to [
            \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff].
            For example, /\s\w*/ matches " bar" in "foo bar".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\S</p>
          <p>
            Matches a single character other than white space. Equivalent to [^
            \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff].
            For example, /\S\w*/ matches "foo" in "foo bar".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\t</p>
          <p>Matches a horizontal tab.</p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\n</p>
          <p>Matches a linefeed.</p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\r</p>
          <p>Matches a carriage return.</p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\v</p>
          <p>Matches a vertical tab.</p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\f</p>
          <p>Matches a form-feed.</p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\0</p>
          <p>Matches a NUL character. Do not follow this with another digit.</p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\cX</p>
          <p>
            Matches a control character using caret notation, where "X" is a
            letter from A-Z (corresponding to codepoints U+0001-U+001A). For
            example, /\cM\cJ/ matches "\r\n".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\xhh</p>
          <p>
            Matches the character with the code hh (two hexadecimal digits).
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\uhhhh</p>
          <p>
            Matches a UTF-16 code-unit with the value hhhh (four hexadecimal
            digits).
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\u{hhhh} or \u{hhhhh}</p>
          <p>
            (Only when the u flag is set.) Matches the character with the
            Unicode value U+hhhh or U+hhhhh (hexadecimal digits).
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">[\b]</p>
          <p>
            Matches a backspace. If you're looking for the word-boundary
            character (\b), see Assertions.
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
      </section>
      <br />
      <hr />
      <section class="chapter" id="assertions">
        <h2>Assertions</h2>
        <p>
          Assertions include boundaries, which indicate the beginnings and
          endings of lines and words, and other patterns indicating in some way
          that a match is possible (including look-ahead, look-behind, and
          conditional expressions).
        </p>
        <div class="mdnDoc">
          <p class="subHeader">^</p>
          <p>
            Matches the beginning of input. If the multiline flag is set to
            true, also matches immediately after a line break character. For
            example, /^A/ does not match the "A" in "an A", but does match the
            first "A" in "An A".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">$</p>
          <p>
            Matches the end of input. If the multiline flag is set to true, also
            matches immediately before a line break character. For example, /t$/
            does not match the "t" in "eater", but does match it in "eat".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\b</p>
          <p>
            Matches a word boundary. This is the position where a word character
            is not followed or preceded by another word-character, such as
            between a letter and a space. Note that a matched word boundary is
            not included in the match. In other words, the length of a matched
            word boundary is zero.
          </p>
          <p><strong>Examples:</strong></p>
          <ul>
            <li>/\bm/ matches the "m" in "moon".</li>
            <li>
              /oo\b/ does not match the "oo" in "moon", because "oo" is followed
              by "n" which is a word character.
            </li>
            <li>
              /oon\b/ matches the "oon" in "moon", because "oon" is the end of
              the string, thus not followed by a word character.
            </li>
            <li>
              /\w\b\w/ will never match anything, because a word character can
              never be followed by both a non-word and a word character.
            </li>
          </ul>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\B</p>
          <p>
            Matches a non-word boundary. This is a position where the previous
            and next character are of the same type: Either both must be words,
            or both must be non-words, for example between two letters or
            between two spaces. The beginning and end of a string are considered
            non-words. Same as the matched word boundary, the matched non-word
            boundary is also not included in the match. For example, /\Bon/
            matches "on" in "at noon", and /ye\B/ matches "ye" in "possibly
            yesterday".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">x(?=y)</p>
          <p>
            Lookahead assertion: Matches "x" only if "x" is followed by "y". For
            example, /Jack(?=Sprat)/ matches "Jack" only if it is followed by
            "Sprat". /Jack(?=Sprat|Frost)/ matches "Jack" only if it is followed
            by "Sprat" or "Frost". However, neither "Sprat" nor "Frost" is part
            of the match results.
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">x(?!y)</p>
          <p>
            Negative lookahead assertion: Matches "x" only if "x" is not
            followed by "y". For example, /\d+(?!\.)/ matches a number only if
            it is not followed by a decimal point. /\d+(?!\.)/.exec('3.141')
            matches "141" but not "3".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">(?&lt=y)x</p>
          <p>
            Lookbehind assertion: Matches "x" only if "x" is preceded by "y".
            For example, /(?&lt=Jack)Sprat/ matches "Sprat" only if it is
            preceded by "Jack". /(?&lt=Jack|Tom)Sprat/ matches "Sprat" only if
            it is preceded by "Jack" or "Tom". However, neither "Jack" nor "Tom"
            is part of the match results.
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">(?&lt!y)x</p>
          <p>
            Negative lookbehind assertion: Matches "x" only if "x" is not
            preceded by "y". For example, /(?&lt!-)\d+/ matches a number only if
            it is not preceded by a minus sign. /(?&lt!-)\d+/.exec('3') matches
            "3". /(?&lt!-)\d+/.exec('-3') match is not found because the number
            is preceded by the minus sign.
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
      </section>
      <br />
      <hr />
      <section class="chapter" id="groupsRanges">
        <h2>Groups & Ranges</h2>
        <p>
          Groups and ranges indicate groups and ranges of expression characters.
        </p>
        <div class="mdnDoc">
          <p class="subHeader">x|y</p>
          <p>
            Matches either "x" or "y". For example, /green|red/ matches "green"
            in "green apple" and "red" in "red apple".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">[xyz][a-c]</p>
          <p>
            A character class. Matches any one of the enclosed characters. You
            can specify a range of characters by using a hyphen, but if the
            hyphen appears as the first or last character enclosed in the square
            brackets it is taken as a literal hyphen to be included in the
            character class as a normal character.
          </p>
          <p>
            For example, [abcd] is the same as [a-d]. They match the "b" in
            "brisket", and the "c" in "chop".
          </p>
          <p>
            For example, [abcd-] and [-abcd] match the "b" in "brisket", the "c"
            in "chop", and the "-" (hyphen) in "non-profit".
          </p>
          <p>
            For example, [\w-] is the same as [A-Za-z0-9_-]. They both match the
            "b" in "brisket", the "c" in "chop", and the "n" in "non-profit".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">[^xyz][^a-c]</p>
          <p>
            A negated or complemented character class. That is, it matches
            anything that is not enclosed in the brackets. You can specify a
            range of characters by using a hyphen, but if the hyphen appears as
            the first or last character enclosed in the square brackets it is
            taken as a literal hyphen to be included in the character class as a
            normal character. For example, [^abc] is the same as [^a-c]. They
            initially match "o" in "bacon" and "h" in "chop".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">(x)</p>
          <p>
            <strong>Capturing group:</strong> Matches x and remembers the match.
            For example, /(foo)/ matches and remembers "foo" in "foo bar".
          </p>
          <p>
            A regular expression may have multiple capturing groups. In results,
            matches to capturing groups typically in an array whose members are
            in the same order as the left parentheses in the capturing group.
            This is usually just the order of the capturing groups themselves.
            This becomes important when capturing groups are nested. Matches are
            accessed using the index of the result's elements ([1], ..., [n]) or
            from the predefined RegExp object's properties ($1, ..., $9).
          </p>
          <p>
            Capturing groups have a performance penalty. If you don't need the
            matched substring to be recalled, prefer non-capturing parentheses
            (see below).
          </p>
          <p>
            String.match() won't return groups if the /.../g flag is set.
            However, you can still use String.matchAll() to get all matches.
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\n</p>
          <p>
            Where "n" is a positive integer. A back reference to the last
            substring matching the n parenthetical in the regular expression
            (counting left parentheses). For example, /apple(,)\sorange\1/
            matches "apple, orange," in "apple, orange, cherry, peach".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\k&ltName&gt</p>
          <p>
            A back reference to the last substring matching the Named capture
            group specified by &ltName&gt.
          </p>
          <p>
            For example, /(?&lttitle&gt\w+), yes \k&lttitle&gt/ matches "Sir,
            yes Sir" in "Do you copy? Sir, yes Sir!".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">\?&ltName&gtx</p>
          <p>
            <strong>Named capturing group:</strong> Matches "x" and stores it on
            the groups property of the returned matches under the name specified
            by &ltName&gt. The angle brackets (&lt and &gt) are required for
            group name.
          </p>
          <p>
            For example, to extract the United States area code from a phone
            number, we could use /\((?&ltarea&gt\d\d\d)\)/. The resulting number
            would appear under matches.groups.area.
          </p>
          <p class="authorLink">MDN WebbDocs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">(?:x)</p>
          <p>
            <strong>Non-capturing group:</strong> Matches "x" but does not
            remember the match. The matched substring cannot be recalled from
            the resulting array's elements ([1], ..., [n]) or from the
            predefined RegExp object's properties ($1, ..., $9).
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
      </section>
      <br />
      <hr />
      <section class="chapter" id="quantifiers">
        <h2>Quantifiers</h2>
        <p>
          Quantifiers indicate numbers of characters or expressions to match.
        </p>
        <div class="mdnDoc">
          <p class="subHeader">x*</p>
          <p>
            Matches the preceding item "x" 0 or more times. For example, /bo*/
            matches "boooo" in "A ghost booooed" and "b" in "A bird warbled",
            but nothing in "A goat grunted".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">x+</p>
          <p>
            Matches the preceding item "x" 1 or more times. Equivalent to {1,}.
            For example, /a+/ matches the "a" in "candy" and all the "a"'s in
            "caaaaaaandy".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">x?</p>
          <p>
            Matches the preceding item "x" 0 or 1 times. For example, /e?le?/
            matches the "el" in "angel" and the "le" in "angle."
          </p>
          <p>
            If used immediately after any of the quantifiers *, +, ?, or {},
            makes the quantifier non-greedy (matching the minimum number of
            times), as opposed to the default, which is greedy (matching the
            maximum number of times).
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">x{n}</p>
          <p>
            Where "n" is a positive integer, matches exactly "n" occurrences of
            the preceding item "x". For example, /a{2}/ doesn't match the "a" in
            "candy", but it matches all of the "a"'s in "caandy", and the first
            two "a"'s in "caaandy".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">x{n,}</p>
          <p>
            Where "n" is a positive integer, matches at least "n" occurrences of
            the preceding item "x". For example, /a{2,}/ doesn't match the "a"
            in "candy", but matches all of the a's in "caandy" and in
            "caaaaaaandy".
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">x{n,m}</p>
          <p>
            Where "n" is 0 or a positive integer, "m" is a positive integer, and
            m &gt n, matches at least "n" and at most "m" occurrences of the
            preceding item "x". For example, /a{1,3}/ matches nothing in "cndy",
            the "a" in "candy", the two "a"'s in "caandy", and the first three
            "a"'s in "caaaaaaandy". Notice that when matching "caaaaaaandy", the
            match is "aaa", even though the original string had more "a"s in it.
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">x*?, x+?, x??, x{n}?, x{n,}?, x{n,m}?</p>
          <p>
            By default quantifiers like * and + are "greedy", meaning that they
            try to match as much of the string as possible. The ? character
            after the quantifier makes the quantifier "non-greedy": meaning that
            it will stop as soon as it finds a match. For example, given a
            string like "some &ltfoo&gt &ltbar&gt new &lt/bar&gt &lt/foo&gt
            thing":
          </p>
          <ul>
            <li>
              /&lt.*&gt/ will match "&ltfoo&gt &ltbar&gt new &lt/bar&gt
              &lt/foo&gt"
            </li>
            <li>/&lt.*?&gt/ will match "&ltfoo&gt"</li>
          </ul>
          <p class="authorLink">MDN Web Docs</p>
        </div>
      </section>
      <br />
      <hr />
      <section class="chapter" id="unicodeEscape">
        <h2>Unicode Escapes</h2>
        <p>
          Before ES2018 there was no performance-efficient way to match
          characters from different sets based on scripts (like Macedonian,
          Greek, Georgian etc.) or propertyName (like Emoji etc) in JavaScript.
          Check out tc39 Proposal on Unicode Property Escapes for more info.
        </p>
        <p>
          Unicode property escapes Regular Expressions allows for matching
          characters based on their Unicode properties. A character is described
          by several properties which are either binary ("boolean-like") or
          non-binary. For instance, unicode property escapes can be used to
          match emojis, punctuations, letters (even letters from specific
          languages or scripts), etc.
        </p>
        <div class="mdnDoc">
          <p class="note">Note:</p>
          <p>
            For Unicode property escapes to work, a regular expression must use
            the u flag which indicates a string must be considered as a series
            of Unicode code points. See also RegExp.prototype.unicode.
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="note">Note:</p>
          <p>
            Some Unicode properties encompasses many more characters than some
            character classes (such as \w which matches only latin letters, a to
            z) but the latter is better supported among browsers (as of January
            2020).
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">Syntax</p>
          <pre class="codeExample">
            <code>
              // Non-binary values
              \p{UnicodePropertyValue}
              \p{UnicodePropertyName=UnicodePropertyValue}
              
              // Binary and non-binary values
              \p{UnicodeBinaryPropertyName}
              
              // Negation: \P is negated \p
              \P{UnicodePropertyValue}
              \P{UnicodeBinaryPropertyName}
            </code>
          </pre>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">General categories</p>
          <p>
            General categories are used to classify Unicode characters and
            subcategories are available to define a more precise categorization.
            It is possible to use both short or long forms in Unicode property
            escapes. They can be used to match letters, numbers, symbols,
            punctuations, spaces, etc. For a more exhaustive list of general
            categories, please refer to the Unicode specification.
          </p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <pre class="codeExample">
          <code>
  // finding all the letters of a text
  let story = "It's the Cheshire Cat: now I shall have somebody to talk to.";

  // Most explicit form
  story.match(/\p{General_Category=Letter}/gu);

  // It is not mandatory to use the property name for General categories
  story.match(/\p{Letter}/gu);

  // This is equivalent (short alias):
  story.match(/\p{L}/gu);

  // This is also equivalent (conjunction of all the subcategories using short aliases)
  story.match(/\p{Lu}|\p{Ll}|\p{Lt}|\p{Lm}|\p{Lo}/gu);
          </code>
        </pre>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">
            Unicode property escapes vs. character classes
          </p>
          <p>
            With JavaScript regular expressions, it is also possible to use
            character classes and especially \w or \d to match letters or
            digits. However, such forms only match characters from the Latin
            script (in other words, a to z and A to Z for \w and 0 to 9 for \d).
            As shown in this example, it might be a bit clumsy to work with non
            Latin texts.
          </p>
          <p>
            Unicode property escapes categories encompass much more characters
            and \p{Letter} or \p{Number} will work for any script.
          </p>
          <pre class="codeExample">
            <code>
              // Trying to use ranges to avoid \w limitations:
              
              const nonEnglishText = "Приключения Алисы в Стране чудес";
              const regexpBMPWord = /([\u0000-\u0019\u0021-\uFFFF])+/gu;
              // BMP goes through U+0000 to U+FFFF but space is U+0020
              
              console.table(nonEnglishText.match(regexpBMPWord));
              
              // Using Unicode property escapes instead
              const regexpUPE = /\p{L}+/gu;
              console.table(nonEnglishText.match(regexpUPE));
            </code>
          </pre>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">Scripts and script extensions</p>
          <p>
            Some languages use different scripts for their writing system. For
            instance, English and Spanish are written using the Latin script
            while Arabic and Russian are written with other scripts
            (respectively Arabic and Cyrillic). The Script and Script_Extensions
            Unicode properties allow regular expression to match characters
            according to the script they are mainly used with (Script) or
            according to the set of scripts they belong to (Script_Extensions).
          </p>
          <p>
            <strong>For example</strong>, A belongs to the Latin script and ε to
            the Greek script.
          </p>
          <pre class="codeExample">
            <code>
              let mixedCharacters = "aεЛ";
              
              // Using the canonical "long" name of the script
              mixedCharacters.match(/\p{Script=Latin}/u); // a
              
              // Using a short alias for the script
              mixedCharacters.match(/\p{Script=Greek}/u); // ε
              
              // Using the short name Sc for the Script property
              mixedCharacters.match(/\p{Sc=Cyrillic}/u); // Л
            </code>
          </pre>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
      </section>
      <br />
      <hr />
      <section class="chapter" id="flags">
        <h2>Flags</h2>
        <p class="subHeader">Advanced searching with flags</p>
        <p>
          Regular expressions have optional flags that allow for functionality
          like global searching and case-insensitive searching. These flags can
          be used separately or together in any order, and are included as part
          of the regular expression.
        </p>
        <div class="mdnDoc">
          <p class="subHeader">d</p>
          <p>Generate indices for substring matches.</p>
          <p class="subHeader">RegExp.prototype.hasIndices</p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">g</p>
          <p>Global search.</p>
          <p class="subHeader">RegExp.prototype.global</p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">i</p>
          <p>Case-insensitive search</p>
          <p class="subHeader">RegExp.prototype.ignoreCase</p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">m</p>
          <p>Multi-line search</p>
          <p class="subHeader">RegExp.prototype.multiline</p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">s</p>
          <p>Allows . to match newline characters.</p>
          <p class="subHeader">RegExp.prototype.dotAll</p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">u</p>
          <p>
            "unicode"; treat a pattern as a sequence of unicode code points.
          </p>
          <p class="subHeader">RegExp.prototype.unicode</p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
        <br />
        <div class="mdnDoc">
          <p class="subHeader">uy</p>
          <p>
            Perform a "sticky" search that matches starting at the current
            position in the target string. See sticky.
          </p>
          <p class="subHeader">RegExp.prototype.sticky</p>
          <p class="authorLink">MDN Web Docs</p>
        </div>
      </section>
      <br />
      <hr />
      <section class="chapter" id="methods">
        <h2>Methods</h2>
        <section class="subChapter" id="regExpMethods">
          <p class="subHeader">RegExp Methods</p>
          <p>
            Regular expressions are used with the
            <strong>RegExp methods</strong> test() and exec()
          </p>
          <div class="mdnDoc">
            <p class="subHeader">exec()</p>
            <p>
              Executes a search for a match in a string. It returns an array of
              information or null on a mismatch.
            </p>
            <p class="authorLink">MDN Web Docs</p>
          </div>
          <br />
          <div class="mdnDoc">
            <p class="subHeader">test()</p>
            <p>Tests for a match in a string. It returns true or false.</p>
            <p class="authorLink">MDN Web Docs</p>
          </div>
          <br />
          <div class="mdnDoc">
            <p class="subHeader">Syntax</p>
            <pre class="codeExample">
            <code>

            </code>
          </pre>
          </div>
        </section>
        <br />
        <section class="subChapter" id="stringMethods">
          <p class="subHeader">String Methods</p>
          <p>
            Regular expressions are also used with the
            <strong>String methods</strong> match(), replace(), search(), and
            split().
          </p>
          <div class="mdnDoc">
            <p class="subHeader">match()</p>
            <p>
              Returns an array containing all of the matches, including
              capturing groups, or null if no match is found.
            </p>
            <p class="authorLink">MDN Web Docs</p>
          </div>
          <br />
          <div class="mdnDoc">
            <p class="subHeader">matchAll()</p>
            <p>
              Returns an iterator containing all of the matches, including
              capturing groups.
            </p>
            <p class="authorLink">MDN Web Docs</p>
          </div>
          <br />
          <div class="mdnDoc">
            <p class="subHeader">search()</p>
            <p>
              Tests for a match in a string. It returns the index of the match,
              or -1 if the search fails.
            </p>
            <p class="authorLink">MDN Web Docs</p>
          </div>
          <br />
          <div class="mdnDoc">
            <p class="subHeader">replace()</p>
            <p>
              Executes a search for a match in a string, and replaces the
              matched substring with a replacement substring.
            </p>
            <p class="authorLink">MDN Web Docs</p>
          </div>
          <br />
          <div class="mdnDoc">
            <p class="subHeader">replaceAll()</p>
            <p>
              Executes a search for all matches in a string, and replaces the
              matched substrings with a replacement substring.
            </p>
            <p class="authorLink">MDN Web Docs</p>
          </div>
          <br />
          <div class="mdnDoc">
            <p class="subHeader">split()</p>
            <p>
              Uses a regular expression or a fixed string to break a string into
              an array of substrings.
            </p>
            <p class="authorLink">MDN Web Docs</p>
          </div>
          <br />
          <div class="mdnDoc">
            <p class="subHeader">Syntax</p>
            <pre class="codeExample">
            <code>

            </code>
          </pre>
            <p class="authorLink">MDN Web Docs</p>
          </div>
        </section>
      </section>
      <br />
      <hr />
      <section class="chapter" id="escaping">
        <h2>Escaping</h2>
        <div class="mdnDoc">
          <p class="subHeader">Escaping</p>
          <p>
            If you need to use any of the special characters literally (actually
            searching for a "*", for instance), you must escape it by putting a
            backslash in front of it. For instance, to search for "a" followed
            by "*" followed by "b", you'd use /a\*b/ — the backslash "escapes"
            the "*", making it literal instead of special.
          </p>
          <p>
            Similarly, if you're writing a regular expression literal and need
            to match a slash ("/"), you need to escape that (otherwise, it
            terminates the pattern). For instance, to search for the string
            "/example/" followed by one or more alphabetic characters, you'd use
            /\/example\/[a-z]+/i—the backslashes before each slash make them
            literal.
          </p>
          <p>
            To match a literal backslash, you need to escape the backslash. For
            instance, to match the string "C:\" where "C" can be any letter,
            you'd use /[A-Z]:\\/ — the first backslash escapes the one after it,
            so the expression searches for a single literal backslash.
          </p>
          <p>
            If using the RegExp constructor with a string literal, remember that
            the backslash is an escape in string literals, so to use it in the
            regular expression, you need to escape it at the string literal
            level. /a\*b/ and new RegExp("a\\*b") create the same expression,
            which searches for "a" followed by a literal "*" followed by "b".
          </p>
          <p>
            If escape strings are not already part of your pattern you can add
            them using String.replace:
          </p>
          <pre class="codeExample">
            <code>
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); 
    // $& means the whole matched string
  }
            </code>
          </pre>
          <p class="authorLink">MDN Web Docs</p>
        </div>
      </section>
    </main>
    <button id="topBtn">
      <img
        src="./img/icon/icons8-wide-right-arrow-64.png"
        alt=""
        title="Top of Page"
      />
    </button>
    <footer class="pageFooter">
      <h2>Christopher Guy O/A Softcorp Industries</h2>
    </footer>
  </body>
</html>
