<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Audiowide&family=Lobster&family=Roboto:ital,wght@0,500;0,700;0,900;1,300&family=The+Nautigal:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <title>JS ES6</title>
    <link rel="stylesheet" href="main.css" />
    <script type="module" src="main.js" defer></script>
  </head>

  <body>
    <nav class="main-nav">
      <h2>JS ES6</h2>
      <ul class="navBar">
        <li class="navBar__list-item">
          <a href="index.html" title="FCC Vanilla javaScript">Home</a>
        </li>
        <li class="navBar__list-item">
          <a href="#es6Variables" title="">ES6 Variables</a>
        </li>
        <li class="navBar__list-item">
          <a href="#arrowFunctions" title="FCC Notes ES6">Arrow Functions</a>
        </li>
        <li class="navBar__list-item">
          <a href="" title="">Expressions</a>
        </li>
      </ul>
    </nav>
    <header class="main-header">
      <div id="darkMode" class="darkMode">
        <button id="darkModeBtn" class="dmToggle"></button>
      </div>
      <h1>javaScript ES6</h1>
    </header>
    <div class="intro">
      <h2>Welcome to ES6</h2>
      <p>
        ECMAScript, or ES, is a standardized version of JavaScript. Because all
        major browsers follow this specification, the terms ECMAScript and
        JavaScript are interchangeable.
      </p>
      <p>
        Most of the JavaScript you've learned up to this point was in ES5
        (ECMAScript 5), which was finalized in 2009. While you can still write
        programs in ES5, JavaScript is constantly evolving, and new features are
        released every year.
      </p>
      <p>
        ES6, released in 2015, added many powerful new features to the language.
        In this course, you'll learn these new features, including arrow
        functions, destructuring, classes, promises, and modules.
      </p>
    </div>
    <main>
      <br>
      <hr>
      <section class="chapter" id="es6Variables">
        <h2>ES6 Variables</h2>
        <p class="subHeader">
          <a
            href="https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/es6/compare-scopes-of-the-var-and-let-keywords"
            target="_blank"
            title="FCC "
            >Compare Scopes of the var and let Keywords</a
          >
        </p>
        <p>
          If you are unfamiliar with <span class="keyword">let</span>, check out
          <a
            href="https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/basic-javascript/explore-differences-between-the-var-and-let-keywords"
            target="_blank"
            >this challenge</a
          >.
        </p>
        <p>
          When you declare a variable with the
          <span class="keyword"> var</span> keyword, it is declared globally, or
          locally if declared inside a function.
        </p>
        <p>
          The <span class="keyword">let</span> keyword behaves similarly, but
          with some extra features. When you declare a variable with the let
          keyword inside a block, statement, or expression, its scope is limited
          to that block, statement, or expression.
        </p>
        <p class="subHeader note">Example:</p>
        <pre class="codeExample">
          <code>
  var numArray = [];
  for (var i = 0; i &lt 3; i++) {
    numArray.push(i);
  }
  console.log(numArray);
  console.log(i);
          </code>
        </pre>
        <p>Here the console will display the values [0, 1, 2] and 3.</p>
        <p>
          With the var keyword, i is declared globally. So when i++ is executed,
          it updates the global variable. This code is similar to the following:
        </p>
        <pre class="codeExample">
          <code>
  var numArray = [];
  var i;
  for (i = 0; i &lt 3; i++) {
    numArray.push(i);
  }
  console.log(numArray);
  console.log(i);
          </code>
        </pre>
        <p>Here the console will display the values [0, 1, 2] and 3.</p>
        <p>
          This behavior will cause problems if you were to create a function and
          store it for later use inside a for loop that uses the i variable.
          This is because the stored function will always refer to the value of
          the updated global i variable.
        </p>
        <pre class="codeExample">
          <code>
  var printNumTwo;
  for (var i = 0; i &lt 3; i++) {
    if (i === 2) {
      printNumTwo = function() {
        return i;
      };
    }
  }
console.log(printNumTwo());
          </code>
        </pre>
        <p>Here the console will display the value 3.</p>
        <p>
          As you can see, printNumTwo() prints 3 and not 2. This is because the
          value assigned to i was updated and the printNumTwo() returns the
          global i and not the value i had when the function was created in the
          for loop. The let keyword does not follow this behavior:
        </p>
        <pre class="codeExample">
          <code>
  let printNumTwo;
  for (let i = 0; i &lt 3; i++) {
    if (i === 2) {
      printNumTwo = function() {
        return i;
      };
    }
  }
  console.log(printNumTwo());
  console.log(i);
          </code>
        </pre>
        <p>
          Here the console will display the value 2, and an error that i is not
          defined.
        </p>
        <p>
          i is not defined because it was not declared in the global scope. It
          is only declared within the for loop statement. printNumTwo() returned
          the correct value because three different i variables with unique
          values (0, 1, and 2) were created by the let keyword within the loop
          statement.
        </p>
        <p class="subHeader">
          <a
            href="https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/es6/mutate-an-array-declared-with-const"
            target="_blank"
          >
            Mutate an Array Declared with const
          </a>
        </p>
        <p>The const declaration has many use cases in modern JavaScript.</p>
        <p>
          Some developers prefer to assign all their variables using const by
          default, unless they know they will need to reassign the value. Only
          in that case, they use let.
        </p>
        <p>
          However, it is important to understand that objects (including arrays
          and functions) assigned to a variable using const are still mutable.
          Using the const declaration only prevents reassignment of the variable
          identifier.
        </p>
        <pre class="codeExample">
            <code>
  const s = [5, 6, 7];
  s = [1, 2, 3];
  s[2] = 45;
  console.log(s);
            </code>
        </pre>
        <p>s = [1, 2, 3] will result in an error.</p>
        <p>The console.log will display the value [5, 6, 45].</p>
        <p>
          As you can see, you can mutate the object [5, 6, 7] itself and the
          variable s will still point to the altered array [5, 6, 45]. Like all
          arrays, the array elements in s are mutable, but because const was
          used, you cannot use the variable identifier s to point to a different
          array using the assignment operator.
        </p>
        <p class="subHeader">
          <a
            href="https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/es6/prevent-object-mutation"
            target="_blank"
            >Prevent Object Mutation</a
          >
        </p>
        <p>
          As seen in the previous challenge, const declaration alone doesn't
          really protect your data from mutation. To ensure your data doesn't
          change, JavaScript provides a function Object.freeze to prevent data
          mutation.
        </p>
        <p>
          Any attempt at changing the object will be rejected, with an error
          thrown if the script is running in strict mode.
        </p>
        <pre class="codeExample">
            <code>
  let obj = {
    name:"FreeCodeCamp",
    review:"Awesome"
    };

  Object.freeze(obj);
  obj.review = "bad";
  obj.newProp = "Test";

  console.log(obj); 
            </code>
        </pre>
        <p>The obj.review and obj.newProp assignments will result in errors, because our editor runs in strict mode by default, and the console will display the value { name: "FreeCodeCamp", review: "Awesome" }.</p>
        
      </section>
      <br>
      <hr>
      <section class="chapter" id="arrowFunctions">
        <h2>Arrow Functions</h2>
        <h3>MDN Web Docs</h3>
        <p class="subHeader">Arrow function expressions</p>
        <p>An arrow function expression is a compact alternative to a traditional function expression, but is limited and can't be used in all situations. </p>
        <br>
        <p>Differences & Limitations:</p>
        <ul>
          <li>Does not have its own bindings to this or super, and should not be used as methods. </li>
          <li>Does not have new.target keyword.</li>
          <li>Not suitable for call, apply and bind methods, which generally rely on establishing a scope. </li>
          <li>Can not be used as constructors.</li>
          <li>Can not use yield, within its body.</li>
        </ul>
        <br>
        <p class="subHeader">Basic Syntax</p>
        <p>One param. With simple expression return is not needed:</p>
        <pre class="codeExample">
          <code>
  param => expression
          </code>
        </pre>
        <br>
        <p>Multiple params require parentheses. With simple expression return is not needed: </p>
        <pre class="codeExample">
          <code>
  (param1, paramN) => expression
          </code>
        </pre>
        <br>
        <p>Multiline statements require body braces and return:</p>
        <pre class="codeExample">
          <code>
  param => {
    let a = 1;
    return a + param;
  }
          </code>
        </pre>
        <br>
        <p>Multiple params require parentheses. Multiline statements require body braces and return: </p>
        <pre class="codeExample">
          <code>
  (param1, paramN) => {
    let a = 1;
    return a + param1 + paramN;
  }
          </code>
        </pre>
        <br>
        <p class="subHeader">Advanced Syntax</p>
        <p>To return an object literal expression requires parentheses around expression: </p>
        <pre class="codeExample">
          <code>
  params => ({foo: "a"}) // returning the object {foo: "a"}
          </code>
        </pre>
        <br>
        <p>Rest parameters are supported:</p>
        <pre class="codeExample">
          <code>
  (a, b, ...r) => expression
          </code>
        </pre>
        <p>Default parameters are supported:</p>
        <pre class="codeExample">
          <code>
  (a=400, b=20, c) => expression
          </code>
        </pre>
        <br>
        <p>Destructuring within params supported:</p>
        <pre class="codeExample">
          <code>
  ([a, b] = [10, 20]) => a + b;  // result is 30
  ({ a, b } = { a: 10, b: 20 }) => a + b; // result is 30
          </code>
        </pre>
        <br>
        <p>For a more indepth look at Arrow functions please visit the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" title="MDN Arrow Functions">MDN web docs</a> page.</p>
        <br>
        <h3>Free Code Camp</h3>
        <p class="subHeader">
          <a href="https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/es6/use-arrow-functions-to-write-concise-anonymous-functions">Use Arrow Functions to Write Concise Anonymous Functions</a>
        </p>
        <p>In JavaScript, we often don't need to name our functions, especially when passing a function as an argument to another function. Instead, we create inline functions. We don't need to name these functions because we do not reuse them anywhere else.</p>
        <p>To achieve this, we often use the following syntax:</p>
        <pre class="codeExample">
          <code>
  const myFunc = function() {
    const myVar = "value";
    return myVar;
  }
          </code>
        </pre>
        <p>ES6 provides us with the syntactic sugar to not have to write anonymous functions this way. Instead, you can use arrow function syntax:</p>
        <pre class="codeExample">
          <code>
  const myFunc = () => {
    const myVar = "value";
    return myVar;
  }
          </code>
        </pre>
        <p>When there is no function body, and only a return value, arrow function syntax allows you to omit the keyword return as well as the brackets surrounding the code. This helps simplify smaller functions into one-line statements:</p>
        <pre class="codeExample">
          <code>
  const myFunc = () => "value";
          </code>
        </pre>
        <p>This code will still return the string value by default.</p>
        <br>
        
      </section>
      <br>
      <hr>
    </main>
    <br />
    <br />
    <br />
    <br />
    <br />
    <button id="topBtn">
      <img src="./img/icon/icons8-wide-right-arrow-64.png" alt="" title="Top of Page" />
    </button>
    <footer class="pageFooter">
      <h2>Christopher T. Guy <span>O/A</span> Softcorp Industries</h2>
    </footer>
  </body>
</html>
